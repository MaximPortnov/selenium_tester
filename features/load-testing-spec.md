# Нагрузочные тесты во вкладках OnlyOffice — первичный вариант

## Цель
Обеспечить сценарии нагрузочного тестирования, где несколько вкладок OnlyOffice выполняют одинаковые или разные действия одновременно, при этом общая подготовка выполняется один раз. Тесты должны запускаться через `pytest`, оставаться простыми для написания, и позволять в будущем автогенерировать шаги из логов UI-нажатий.

>> КОММЕНТАРИЙ: надо еще чтоб результат сохранялся в что то на подобии SQLite для удобного проверки результатов, в моем голове это выглядит так что с нагрузочным тестированием будет несколько столбцов а строки относятся ко времени, то есть каждой столбец по сути это лог и если в первом логе между двумя записями в втором логе произошло 4 действия то в таблице у первого лога должно быть запись -> 4 пустых строки и запись, а во втором логе будет пустая строка -> 4 записи -> пустая строка. грубо это один вид вывода записи логов в таблицу

## Контекст и ограничения
- Подключение к уже запущенному OnlyOffice через `debuggerAddress=127.0.0.1:9222` (см. `src/driver.py`).
- Selenium WebDriver управляет вкладками одного окна (`window_handles`). WebDriver не потокобезопасен.
- Локаторы сосредоточены в PageObject-файлах под `src/pages/`.
- Подготовительные шаги (открытие плагина, выбор подключения и т.п.) должны выполняться один раз и переиспользоваться вкладками.
- Не хотим усложнять тесты: целевой синтаксис близок к "описать шаги сценария" без ручного свитча вкладок.

## Варианты реализации
1) **Оркестратор на одном WebDriver (round-robin по вкладкам)**
   - Создаём N вкладок в одном окне; храним `window_handle` для каждой.
   - Определяем `TabSession` (wraps driver + handle) и `MultiTabRunner`, который чередует шаги разных сценариев (псевдо-параллельность).
   - Плюсы: минимальные изменения, не требует нескольких DevTools-сессий, стабильность. Минусы: нет реального параллелизма, нагрузка ограничена скоростью одного потока.

2) **pytest-xdist + несколько WebDriver-сессий к одному экземпляру OnlyOffice**
   - Каждый worker `xdist` подключается к тому же `debuggerAddress`, открывает свою вкладку и работает независимо.
   - Плюсы: параллельное выполнение на уровне процессов. Минусы: возможны гонки DevTools/OnlyOffice; нужно протокол открытия вкладок, чтобы workers не мешали друг другу.

3) **Несколько экземпляров OnlyOffice (разные порты) + xdist**
   - Стартуем по экземпляру Editors на порты 9222, 9223, ...; каждому worker выдаём свой порт.
   - Плюсы: настоящая изоляция, высокая нагрузка. Минусы: тяжёлый старт, сложнее CI, может быть избыточно для MVP.

> Рекомендуемый старт: вариант 1 как безопасный MVP, с возможностью эволюции к варианту 2 для более высокой нагрузки, если подтвердится работоспособность нескольких DevTools-сессий.

>> КОММЕНТАРИЙ: третий вариант сразу отпадает, но вариант 1 с возможностью эволюции к варианту 2 мне нравится. Но у меня появилась идея, подумай хорошая ли она, если нет то можешь об этом сказать открыто. Идея в том чтоб не использовать полный параллелизм а использовать Корутины, чтоб вызвав клик по одной кнопки(а после нажатия некоторых кнопках долгое ожидание завершения действия, пример при заходе в менеджер sql идет проверка каждого подключений, что занимает несколько десятков секунд, после нажатия менеджер sql можно идти нажимать в других вкладках на следующие кнопки). 

## Предлагаемая архитектура (для варианта 1)
- **Новый модуль** `src/utils/multitab.py`:
  - `class TabSession`: хранит ссылку на общий `DriverOnlyOffice` и конкретный `handle`; методы `activate()`, `run(step_fn)`, контекстный менеджер.
  - `class MultiTabRunner`:
    - `create_tabs(n, prep_fn=None)`: создаёт вкладки, опционально выполняет подготовку на каждой.
    - `add_scenario(name, steps: list[Callable[[TabSession], None]])` или декоратор `@runner.scenario`.
    - `run_round_robin()` / `run_sequential()` / опционально `run_threaded(lock=...)` для будущего.
    - Сбор метрик через `Timer` на уровень вкладки (start/step/summary => логгер).
  - Хуки для будущей автогенерации: `runner.play(script: list[Step])`, где `Step` может быть получен из логов.

- **Фикстуры pytest** (планируется в `conftest.py` или `test/fixtures/multitab.py`):
  - `onlyoffice_driver` (reuse существующего). `scope="session"`.
  - `tab_runner(request)`: читает маркеры/опции (`--tabs N`, `--tab-mode=round_robin|xdist`) и возвращает `MultiTabRunner`.
  - `common_setup`: выполняет общую подготовку один раз (открыть плагин, импортировать соединения если нужно, авторизация), результат (например, выбранное подключение) передаётся в `prep_fn` для каждой вкладки.

- **API тестов (целевой синтаксис)**
  - Одинаковые действия в разных вкладках (MVP):
    ```python
    def test_multi_tabs_same_action(tab_runner, sql_manager_page):
        def scenario(tab: TabSession):
            tab.activate()
            sql_manager_page.open_connection("demo")
            sql_manager_page.run_query("select 1")
        tab_runner.create_tabs(n=3, prep_fn=lambda tab: sql_manager_page.ensure_ready(tab))
        tab_runner.add_scenario("select_1", [scenario])
        tab_runner.run_round_robin()
    ```
  - Разные тесты на разных вкладках с общей подготовкой:
    ```python
    def test_multi_tabs_different(tab_runner, sql_manager_page):
        def prep(tab):
            tab.activate(); sql_manager_page.ensure_ready(tab)
        tab_runner.create_tabs(n=3, prep_fn=prep)

        def scenario_a(tab): tab.activate(); sql_manager_page.run_query("select count(*) from orders")
        def scenario_b(tab): tab.activate(); sql_manager_page.export_result("orders.csv")
        def scenario_c(tab): tab.activate(); sql_manager_page.preview_query("select * from orders limit 10")

        tab_runner.add_scenario("count", [scenario_a])
        tab_runner.add_scenario("export", [scenario_b])
        tab_runner.add_scenario("preview", [scenario_c])
        tab_runner.run_round_robin()
    ```
  - Для будущей автогенерации из логов: предусмотреть `tab_runner.play(script_from_log)`; `script_from_log` может быть JSON/YAML со списком селекторов/действий.

## Планируемые файлы/точки изменений
- `features/` (текущий файл) — спецификация.
- `src/utils/multitab.py` — оркестратор и сущности вкладок.
- `test/conftest.py` или `test/fixtures/multitab.py` — фикстуры и опции CLI.
- `test/test_multitab_load.py` — примеры e2e сценариев + smoke для оркестратора.
- `docs/AGENT_NOTES.md` и `_RU.md` — после реализации добавить раздел «Многовкладочные нагрузочные тесты» с шагами запуска.

## Риски и ограничения
- Настоящего параллелизма в Selenium при одном драйвере нет; нагрузка ограничена serial round-robin.
- DevTools-подключение может не поддерживать несколько драйверов одновременно; это нужно подтвердить, прежде чем выбирать вариант 2.
- Вкладки OnlyOffice могут требовать фокус/активное окно — нужно проверить, как это влияет на выполнение действий в неактивной вкладке.
- Общая подготовка: если она меняет глобальное состояние (выбор соединения), нужно определить, копируется ли оно на все вкладки или привязано к конкретной.

## Открытые вопросы к заказчику (нужны ответы перед реализацией)

1) Сколько вкладок должно поддерживаться в боевом прогоне (min/max)?  

- без понятия будем исследовать этот момент на боевом прогоне

2) «Одновременность» для MVP: устраивает round-robin/интерливинг (без xdist), или закладываем сразу xdist (несколько WebDriver-сессий к одному OnlyOffice)?

- не понимаю о чем ты

3) Общие подготовительные шаги: какие именно? (открыть документ, открыть плагин, выбрать конкретное подключение, ещё что-то?)  

- открытие документа у всех разное, но после появляются одинаковые действия такие как нажать на кнопки editorPage.click_plugin_button() editorPage.try_click_close() pluginPage.click_sql_mode() pluginPage.sql_mode.click_make_sql(), я это имею введу

4) Метрики/SLA: какие пороги считаем провалом (preview, export и т.п.)? Либо только логируем без фейла? 

- тут все сложно вообще фейлом надо считать падение с ошибкой, не соответствие сриншотов(где то это кретично где то нет это в тестах должно быть прописано), скриншоты могут выдавать ошибку или не выдавать. дальше надо будет падать если отсутствует какой то элемент если на него нельзя нажать и все такое.

5) Критичные сценарии первой очереди (SQL preview/export? что ещё) и сколько разных сценариев одновременно (2–3?)  

- не понял вопрос

6) SQLite как основной артефакт? Нужен ли дублирующий JSON/CSV? Допустимый размер файла на прогон?

- я думаю тут надо сделать так чтоб внутри формировалась таблица который потом ее можно было перевести в разные форматы. но для начала надо сделать sqlite, но не сейчас это будет следующей фичей(можешь создать для этой фичи отдельный документ)

7) Формат «скриптов из логов» для будущего автоплея: JSON или YAML? Где хранить (например, `features/scripts/`)?  

- тут тоже сейчас ничего особо делать не надо, это будет будущей фичей, и тоже можешь создать отдельный документ для это вещи 

8) Артефакты: ок ли путь `artifacts/load/<timestamp>.db` и текстовый лог рядом?   

- пока делать не надо

9) Корутин-идея: достаточно явного `run_interleaved(schedule)` (чередуем шаги разных вкладок), или хочется автоматического «переключай вкладку, пока первая ждёт»? Если второе — опиши ожидаемое поведение.

- не знаю как это должно выглядит и сработает ли



>> КОММЕНТАРИЙ: я сейчас хочу сделать грубо говоря пробу пера, сделать минимально несколько подходов чтоб понять какие работают а какие нет, сейчас надо сконцентрироваться только на нагрузочных тестах

## Резюме ответов заказчика (фиксируем договорённости)
- Вкладок: пока неизвестно, определить опытно на боевом прогоне.
- Одновременность: заказчик не про xdist; ждёт «пробу пера» на одной сессии, готов к идее интерливинга шагов между вкладками.
- Общая подготовка: открыть редактор, нажать `editorPage.click_plugin_button()`, `editorPage.try_click_close()`, `pluginPage.click_sql_mode()`, `pluginPage.sql_mode.click_make_sql()`. Открытие документа у всех разное.
- Метрики/SLA: падение по фактическим ошибкам (исключения, отсутствие элементов, критичные несовпадения скринов). Тайм-ауты/пороги пока не заданы — логировать, но не фейлить по времени.
- Критичные сценарии: заказчик пока не сформулировал.
- SQLite: нужен, но как отдельная фича позже; сейчас можно ограничиться логами. Дополнительный документ под фичу SQLite допускается.
- Скрипты из логов: тоже отдельная будущая фича; можно завести отдельный документ.
- Артефакты пути: пока не делать.
- Корутин-идея: непонятно, нужно попробовать интерливинг и посмотреть, даст ли выигрыш.
- Сейчас фокус только на нагрузочных тестах (минимальные подходы, чтобы понять, что работает).

## Предлагаемый план MVP (проба пера)
1) **Оркестратор v0 (без xdist)**  
   - Реализовать `MultiTabRunner`/`TabSession` на одном WebDriver.  
   - Поддержать два режима:  
     - `run_round_robin()` — текущий простой чередователь.  
     - `run_interleaved(schedule)` — явный список шагов с указанием вкладки, чтобы имитировать «корутину» (пока синхронно).
2) **Подготовка вкладок**  
   - В `create_tabs(prep_fn)` вызвать общий подготовительный блок: `click_plugin_button()`, `try_click_close()`, `click_sql_mode()`, `click_make_sql()`.  
   - Открытие документа остаётся на ответственности сценария.
3) **Фикстуры pytest**  
   - `tab_runner` (scope=session), CLI `--tabs N`, `--tab-mode=round_robin|interleaved`.  
   - Пример теста с 2–3 вкладками и простыми шагами (preview / export) для проверки жизнеспособности.
4) **Логирование/тайминги**  
   - Логгер + `Timer` на сценарий/вкладку; пока без SLA-вализации (только лог).  
   - Визуальные проверки подключаем точечно (опционально, без падений по умолчанию).
5) **Что НЕ делаем в MVP**  
   - xdist/несколько драйверов.  
   - SQLite-писатель и форматирование «пустых строк» — вынесено в отдельную будущую фичу (завести отдельный документ).  
   - Генерация/проигрывание скриптов из логов — отдельный документ на будущее.  
   - Падение по SLA времени.

## Предлагаемые следующие шаги (для обсуждения в файле)
- Утвердить, что MVP = пункты 1–4 выше и исключения в «НЕ делаем».  
- Если ок, я зафиксирую дизайн классов (`MultiTabRunner`, `TabSession`, API interleaved schedule) и примерный тест `test_multitab_load.py`.  
- Параллельно заведу два черновика под будущие фичи:  
  - `features/load-logs-sqlite.md` — формат и рендер событий в SQLite/табличный вид.  
  - `features/log-scripts-replay.md` — формат скриптов из логов (JSON/YAML) и hook `tab_runner.play`.
