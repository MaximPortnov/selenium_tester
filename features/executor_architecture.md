# Архитектура нового replay-исполнителя

Статус: `черновик для согласования (без реализации)`  
Текущий файл нужен как единый документ требований перед кодингом.

## 1. Зачем меняем текущий подход
Проблема: `src/interaction_log_executor.py` сложно поддерживать при росте числа элементов интерфейса.  
Цель: получить более простой и масштабируемый исполнитель, где 100+ кнопок можно обрабатывать по правилам, а не добавлять длинные ветки условий.

## 2. Что хотим получить (целевое поведение)
1. Исполнитель читает `interaction-log-*.jsonl`.
2. Для каждого шага выбирает действие по простой схеме:
   - сначала попытка маршрута по правилам (`testId`/префиксам),
   - потом fallback на универсальный клик/ввод по селектору,
   - для неподдерживаемых событий понятное логирование.
3. Правила маршрутизации вынесены в конфиг (JSON), чтобы добавление новых кнопок было без правок Python-кода.
4. В v1 режим выполнения только строгий (fail-fast): при ошибке сразу падать и показывать, что именно пошло не так.
5. `best-effort` откладывается на потом как отдельное расширение.

## 3. Принципы новой архитектуры
1. Плоский пайплайн выполнения шага (минимум скрытого состояния).
2. Конфиг важнее кода: новые кнопки покрываются через правила.
3. Предсказуемый fallback.
4. Явные и короткие логи ошибок (строка лога, `seq`, `event/action`, `testId`).
5. Совместимость с текущими PageObject-классами в `src/pages`.

## 4. Предлагаемый high-level дизайн (для обсуждения)
1. `ReplayStep`:
   - нормализованные поля из JSONL (`event`, `action`, `testId`, `selector`, `id`, `value`, `text`, `seq`).
2. `RouteResolver`:
   - `exact_click`: точное сопоставление `testId -> page.method`.
   - `prefix_click`: правила по префиксам и шаблонам имен.
3. `ActionExecutor`:
   - `click`: route -> generic click.
   - `set-value`: route(optional) -> generic set value.
4. `ReplayEngine`:
   - загрузка шагов;
   - выполнение шагов строго в порядке файла (без фильтрации по последней сессии `seq` в v1);
   - fail-fast политика ошибок (остановка на первой ошибке с подробной диагностикой).
5. `routes.json`:
   - внешняя настройка кнопок и переопределений.

## 5. Минимальная логика выполнения шага (draft)
1. Игнорировать `keydown/keyup/keypress` по умолчанию.
2. Для `click`:
   - exact route;
   - prefix route;
   - generic click через `selector` -> `[data-testid='...']` -> `id`.
3. Для `input/change/codemirror-change`:best_effort
   - generic set value (input/textarea/select/custom element).
4. Если элемент не найден:
   - в v1: exception и остановка выполнения;
   - best-effort: не реализуем в первой итерации, вернемся позже при необходимости.

## 6. Формат конфигурации (draft)
```json
{
  "exact_click": {
    "main-sql-mode": "plugin.click_main_sql_mode",
    "sql-home-open-sql-manager": {
      "page": "sql_mode",
      "method": "click_sql_manager"
    }
  },
  "prefix_click": [
    {
      "prefix": "main-",
      "page": "plugin",
      "method_template": "click_{test_id_snake}"
    },
    {
      "prefix": "sql-home-open-",
      "page": "sql_mode",
      "strip_prefix": "sql-home-open-",
      "method_template": "click_{suffix_snake}"
    }
  ]
}
```

Шаблоны:
1. `{test_id}`: полный `testId`.
2. `{test_id_snake}`: `testId` с `-` -> `_`.
3. `{suffix}`: часть после `strip_prefix`.
4. `{suffix_snake}`: `suffix` с `-` -> `_`.

## 7. Критерии готовности (Definition of Done)
1. Один новый файл-исполнитель с простой архитектурой (без длинных ветвлений).
2. Один конфиг-механизм маршрутов.
3. Прогон минимум на 1 реальном логе без ручных правок в коде.
4. Тесты на:
   - парсинг лога,
   - резолв exact/prefix маршрутов,
   - fallback-режим,
   - fail-fast поведение (остановка на первой ошибке).
5. Обновленные docs EN/RU с примерами запуска.

## 8. Риски и как снижать
1. Потеря сложной state-логики (active card и т.п.).
   - Митигация: оставить старый executor для advanced-кейсов.
2. Недостаток данных в логах (`testId` пустой).
   - Митигация: fallback по `selector/id`, плюс ручные override-правила.
3. Нестабильные селекторы.
   - Митигация: унифицировать `data-testid` и naming convention.

## 9. Вопросы к вам (заполните прямо в документе)
Ниже ключевые вопросы. Ответы можно писать после каждого пункта в формате `Ответ: ...`.

1. Приоритет целей:
   - Что важнее: максимальная простота кода или максимальная совместимость со старыми логами?
   - Ответ: не понял вопроса, что значит совместимость со старыми логами

2. Поддерживаемые события:
   - Какие `event/action` обязательно должны работать в первой версии?
   - Можно ли в v1 полностью игнорировать keyboard события?
   - Ответ: каждая строка логов должна отрабатываться. По поводу второго скорее всего да.

3. Политика ошибок по умолчанию:
   - По дефолту strict или best-effort?
   - Где допустим skip, а где обязательно падать?
   - Ответ: strict/fail-fast. В v1 не скипаем ошибки, останавливаемся и показываем диагностику.

4. Автоматизация 100+ кнопок:
   - Есть ли уже стабильная схема `data-testid` (префиксы, naming)?
   - Какие префиксы нужно поддержать в первую очередь?
   - Ответ: data-testid все уникальны и не повторяются, максимум справа что то может добавляться.

5. Конфиг:
   - Нужен один глобальный JSON или несколько файлов по разделам (plugin/sql_mode/sql_manager)?
   - Должен ли конфиг поддерживать комментарии (jsonc) или только strict JSON?
   - Ответ: думаю сначала можно обойтись без конфига а сделать код в питоне, потом если будет не удобно сделать отдельным файлом.

6. Fallback:
   - Разрешаем ли generic click на неизвестной кнопке без route?
   - Или любое неизвестное действие считаем ошибкой?
   - Ответ: да, делать поиск и клик с помощью basePage (_click_locator)

7. Совместимость:
   - Новый исполнитель должен жить рядом со старым (`interaction_log_executor.py`) без замены?
   - Нужен ли единый интерфейс запуска для обоих?
   - Ответ: interaction_log_executor.py удалится, так что вообще про него забудь. по поводу запуска можешь делать как посчитаешь нужным и удобным.

8. Режимы запуска:
   - Какие CLI-флаги точно нужны в v1 (`--dry-parse`, `--all-sessions`, `--continue-on-error`, `--routes-config`)?
   - Нужен ли `--no-prepare`?
   - Ответ: режимов с продолжением по ошибкам в v1 не закладываем; фильтрацию по `seq` откладываем на потом.

9. Scope первой итерации:
   - Какие конкретные 5-10 кнопок/сценариев считаются must-have для приемки?
   - Приложите конкретный лог-файл(ы), по которым будем валидировать.
   - Ответ: я буду смотреть тестировать на это interaction-log-1770617001076.jsonl, так же надо выполнять стандартные действия перед выполнением лога.     home_page.open_creation_cell() editor_page.click_plugin_button() editor_page.try_click_close()

10. Логирование и отладка:
   - Какие поля в логе обязательны (line, seq, testId, selector, page, duration)?
   - Нужен ли отдельный machine-readable отчет (json)?
   - Ответ: сначала все будет достаточно просто, потом логи надо будет выдавать в формате sqlite но это другая фича, логи делать через стандартный логгер который прописан. 

11. PageObjects:
   - Новые методы в `src/pages/*` добавляем только если без них нельзя?
   - Или допускается активное расширение PageObject сразу в первой версии?
   - Ответ: src/pages/ будет дополняться постоянно, добавляться новые экраны и кнопочки так как у некоторых кнопок сложная логика нажатия и ожидания

12. Стратегия миграции:
   - Нужен ли feature-flag/переключатель между old/new executor?
   - Когда планируете переключать основный поток на новый?
   - Ответ: я сразу перейду на новый, миграции никакой не надо так как нечего мигрировать

## 10. Решения, которые ждем от вас перед реализацией
1. Подтвержденный список обязательных `event/action` для v1.
2. Подтвержденный набор префиксов `testId` и naming rules.
3. Политика ошибок v1: только strict/fail-fast.
4. Подтверждение, что фильтрация по последней `seq`-сессии не входит в v1.
5. Перечень эталонных логов для приемки.
6. Решение: совместный запуск old/new или полный переход.

После заполнения этого документа переходим к реализации.
